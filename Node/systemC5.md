# 第五章 资源分配与调度

## 5.1 资源管理概述

### 5.1.1资源管理的目的和任务

​	资源是应用程序执行时所需要的全部硬件，软件和数据。计算机系统拥有大量的资源，管理好各类资源是计算机系统的一个重要职责。

#### 1.资源的静态分配和动态分配

静态分配：在作业被调度时，根据用户给出的信息进行分配，并在作业运行完毕后释放所获得的全部资源。

动态分配：进程所需要的资源是在进程运行中根据运行情况动态地分配，使用和释放的。

资源管理的目的：为用户提供一种简单而有效地使用资源的方法，充分发挥各种资源的利用率。

应达到的目的：

1. 保证资源的高利用率
2. 对不可共享的资源实施互斥使用
3. 防止由资源分配不当而引起的死锁

#### 2.资源管理的任务

- 资源数据结构的描述
- 确定资源的分配原则和调度原则
- 执行资源分配
- 存取控制和安全保护

### 5.1.2虚拟资源

​	**虚拟资源**是用户使用的**逻辑资源**，是经过操作系统改造的，使用方便的虚资源，而不是那些物理的，实际的资源。这样做的**目的**，一是**提高资源利用率**，二是**为了方便用户的使用**。

## 5.2资源管理的机制和策略

### 5.2.1资源分配机制

#### 1.资源描述器

描述各类资源的最小分配单

| `资源描述器` |
| :----------: |
|    资源名    |
|   资源类型   |
|   分配标志   |
|    ......    |

位的数据结构称为资源描述器rd(resource description)。资源描述器描述了资源的特性和该资源的管理方式。对于各类资源来说，若它具有n个资源分配的单位，则有n个资源描述器。

#### 2.资源信息块

对于每类资源实施有效的分配，必须设置相应的**资源信息块rib(resource information block)**。**资源信息块**是这样一个数据结构，它**描述了某类资源的请求者**，可利用的资源以及该类资源分配程序的地址。

### 5.2.2资源分配策略

1.先请求先服务(FIFO策略)

2.优先调度

3.针对设备特性的调度

​	几种移臂调度算法

- 最短寻道时间优先算法(SSTF)

  总是从等待访问者中挑选寻找时间最短的那个请求先执行。例子：读写磁头在65号柱面上执行操作，等待访问者按请求的先后次序排序，依次要访问的**柱面为130,32,159,61,75**。若65号柱面的操作结束后，按该算法，**其处理次序为61,75,32,130,159。**

  优点：可减少寻道时间，因而缩短了为各访问者请求服务的平均时间，也就提高了系统效率。

  缺点：可能会引起读写头在盘面上的大范围移动，该算法有高度局部化的倾向，会推迟一些请求的服务，甚至引起无限拖延。

- 电梯调度算法(Scan算法)

  该算法是从移动臂当前位置开始，沿着臂的移动方向去选择离当前移动臂最近的那个柱面访问者，如果沿臂的移动方向无请求访问时，就改变臂的移动方向再选择。

  上述实例130,32,159,61,75。按照Scan算法，其处理次序为65,75,130,159,61,32。

  Scan算法在很大程度上消除了SSTF算法的不公平性，但仍有利于对中间磁道的请求。

## 5.3死锁

### 5.3.1 死锁的定义和例子

**定义**：在两个或多个并发进程中，如果**每个进程持有某种资源**而又都**等待着别的进程释放它**或它们现在保持着的资源，在未改变这种状态之前**都不能向前推进**，称这一组进程发生了**死锁**。

### 5.3.2 产生死锁的原因和必要条件

根本原因：**系统能够提供的资源个数比请求该资源的进程数要少**。

**产生死锁的四个必要条件**：

1. **互斥条件**

   多进程共享的资源具有互斥的特性，一次只能由一个进程使用。

2. **不剥夺条件**

   进程所获得的资源在未使用完毕之前，不能被其他进程夺走，只能由自己来释放。

3. **占有并等待**

   进程每次申请它所需要的一部分资源，在等待新资源时，进程继续占用已分配到的资源。

4. **环路条件(循环等待)**

   存在一种进程的循环链，链中每一个进程已获得的资源同时被链中的下一个进程所请求。

### 5.3.3死锁的预防

死锁预防是通过约束资源请求，使得4个死锁条件中的至少1个被破坏，从而防止死锁发生

* **间接的死锁预防（防止死锁条件1\~3）**
    * **预防互斥**：一般来说，不可能禁止
    * **预防占有且等待**：可以要求进程一次性地请求所有需要的资源，并且阻塞进程直到所有请求都同时满足。这种方法在两个方面是低效的：1）为了等待满足其所有请求的资源，进程可能被阻塞很长时间。但实际上只要有一部分资源，就可以继续执行；2）分配的资源有可能有相当长的一段时间不会被使用，且在此期间，这些资源不能被其它进程使用；除此之外，一个进程可能事先并不会知道它所需要的所有资源
    * **预防不可抢占**：有几种方法：1）如果占用某些资源的进程进一步申请资源时被拒，则释放其占用的资源；2）如果一个进程请求当前被另一个进程占有的一个资源，操作系统可以抢占另一个进程，要求它释放资源(方法2只有在任意两个进程优先级不同时，才能预防死锁)；此外，通过预防不可抢占来预防死锁的方法，只有在资源状态可以很容易保存和恢复的情况下才实用
* **直接的死锁预防（防止死锁条件4）** 
    * **预防循环等待**：可以通过定义资源类型的线性顺序来预防，如果一个进程已经分配到了R类型的资源，那么它接下来请求的资源只能是那些排在R类型之后的资源；这种方法可能是低效的，会使进程执行速度变慢，并且可能在没有必要的情况下拒绝资源访问

> 都会导致低效的资源使用和低效的进程运行

### 5.3.4 死锁的避免

#### 1.有序资源分配法

系统要求每个进程：

1. 对它所必须使用的而且属于某一类的所有资源，必须一次申请完。
2. 在申请不同类的资源时，必须按各类的编号依次申请。

该策略破坏了产生死锁的环路条件。有序资源分配法无疑比静态方法提高了资源的利用率，但它的缺点是进程实际需要资源的顺序不一定与资源的编号相一致，因而仍然会造成资源的浪费。

#### 2.银行家算法

当进程申请一组资源时，该算法需要检查申请者对各类资源的最大需求量，如果系统现存的各类资源的数量可以满足当前它对各类资源的最大需求量，就满足当前的申请；否则，进程必须等待，直到其他进程释放足够的资源为止。

例子：

| 进程 | 已占资源个数 | 还需申请资源个数 |
| :--: | :----------: | :--------------: |
|  p1  |      4       |        4         |
|  p2  |      2       |        2         |
|  p3  |      2       |        7         |

此时只剩2个资源实例，按照该算法p2的申请可以满足，因为p2最多可再申请2个，可以满足它的最大需求。

按照银行家算法来分配资源是不会产生死锁的。因为，按该算法，每次分配后总存在着一个进程，如果让它进行，必然可以获得它所需要的全部资源。

**优点**

* 不需要死锁预防中的抢占和回滚进程，并且比死锁预防的限制少。比死锁预防允许更多的并发

**缺点**

* 必须事先声明每个进程请求的最大资源
* 总是考虑最坏的情况，开销较大。

### 5.3.5 死锁的检测与忽略

